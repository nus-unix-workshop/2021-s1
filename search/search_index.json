{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unix 101: The NUS SoC Unix@Home Workshop AY20/21 Semester 1 About The NUS SoC Unix Workshop is a workshop organized by faculty members of the School of Computing, National University of Singapore, for first-year students. This year, we will conduct the \"Unix@Home\" version, entirely online via Zoom. Objectives The aims of the workshop are To introduce students to using Unix-based computing environment for daily computing tasks To prepare students to be efficient in using Unix for their computing career After taking the workshop, students are expected to: Understand common terminology: Unix, Linux, Ubuntu, SunOS, ssh, host, command line, shell, operating systems, etc. Appreciate the advantages of the Unix environment Understand the Unix file organization Able to perform common file management tasks (create/copy/move/remove/change permission, etc) through Unix shell (For Windows 10 users) Setup local Unix environment Setup apt (Win10) or Homebrew (macOS) and able to use it to install library or applications Time and Venue There will be two versions of the workshop, one for macOS users, the other for Windows 10 users. The date and time are as follows: 3-4 August , 2020 (Mon - Tue), 9:00 to 11:30 am each day. for macOS users only 6-7 August , 2020 (Thu - Fri), 9:00 to 11:30 am each day. for Windows 10 users only The workshop will be conducted online via Zoom. Registration First-year students taking CS1010, CS2030, CS2030S, and CS2040 in Semester 1 of AY2020/21 will be given priority to register for and to attend the workshop. The workshop is sponsored by the NUS School of Computing and is free to attend. Space, however, is limited -- please register only if you are committed to attending. Please register here. before 28 July, 2020 . License The content of this site is licensed under the Creative Common Attribution-NonCommercial-ShareAlike 4.0 International license","title":"Home"},{"location":"#unix-101-the-nus-soc-unixhome-workshop","text":"","title":"Unix 101: The NUS SoC Unix@Home Workshop"},{"location":"#ay2021-semester-1","text":"","title":"AY20/21 Semester 1"},{"location":"#about","text":"The NUS SoC Unix Workshop is a workshop organized by faculty members of the School of Computing, National University of Singapore, for first-year students. This year, we will conduct the \"Unix@Home\" version, entirely online via Zoom.","title":"About"},{"location":"#objectives","text":"The aims of the workshop are To introduce students to using Unix-based computing environment for daily computing tasks To prepare students to be efficient in using Unix for their computing career After taking the workshop, students are expected to: Understand common terminology: Unix, Linux, Ubuntu, SunOS, ssh, host, command line, shell, operating systems, etc. Appreciate the advantages of the Unix environment Understand the Unix file organization Able to perform common file management tasks (create/copy/move/remove/change permission, etc) through Unix shell (For Windows 10 users) Setup local Unix environment Setup apt (Win10) or Homebrew (macOS) and able to use it to install library or applications","title":"Objectives"},{"location":"#time-and-venue","text":"There will be two versions of the workshop, one for macOS users, the other for Windows 10 users. The date and time are as follows: 3-4 August , 2020 (Mon - Tue), 9:00 to 11:30 am each day. for macOS users only 6-7 August , 2020 (Thu - Fri), 9:00 to 11:30 am each day. for Windows 10 users only The workshop will be conducted online via Zoom.","title":"Time and Venue"},{"location":"#registration","text":"First-year students taking CS1010, CS2030, CS2030S, and CS2040 in Semester 1 of AY2020/21 will be given priority to register for and to attend the workshop. The workshop is sponsored by the NUS School of Computing and is free to attend. Space, however, is limited -- please register only if you are committed to attending. Please register here. before 28 July, 2020 .","title":"Registration"},{"location":"#license","text":"The content of this site is licensed under the Creative Common Attribution-NonCommercial-ShareAlike 4.0 International license","title":"License"},{"location":"chmod/","text":"Unit 6: File Permission Management File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right. The What of File Permissions Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3. The Who of File Permissions Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read Checking file permission You can view the permission of a file by using the ls -l command ( l for long format): $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644. The chmod command You can use chmod command to change the permissions of a file or a directory. For instance, $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Common Scenarios for chmod Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x . Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9","title":"6. File Permissions"},{"location":"chmod/#unit-6-file-permission-management","text":"File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right.","title":"Unit 6: File Permission Management"},{"location":"chmod/#the-what-of-file-permissions","text":"Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3.","title":"The What of File Permissions"},{"location":"chmod/#the-who-of-file-permissions","text":"Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read","title":"The Who of File Permissions"},{"location":"chmod/#checking-file-permission","text":"You can view the permission of a file by using the ls -l command ( l for long format): $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644.","title":"Checking file permission"},{"location":"chmod/#the-chmod-command","text":"You can use chmod command to change the permissions of a file or a directory. For instance, $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt","title":"The chmod command"},{"location":"chmod/#common-scenarios-for-chmod","text":"Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x . Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9","title":"Common Scenarios for chmod"},{"location":"efficiency/","text":"Unit 10: Leveling Up Your Productivity with CLI Minimizing Hand Movements In Day 1 of the workshop, you have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. You do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type. Minimizing Typing We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use ++control-p++ or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivity, if you are keen, take a look here: https://github.com/fliptheweb/bash-shortcuts-cheat-sheet You have also seen in Day 1 of the workshop that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for the shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: $ bash hello.sh hello! or $ bash < hello.sh hello! Recall that we said Unix shells do not necessarily interact with the users? This is an example. We pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions unit that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: $ chmod u+x hello.sh $ ./hello.sh hello! Now we can run our script without typing bash . We can remove ./ as well, but we will learn about that only when we talk about environment variables . The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"10. Productivity with Unix"},{"location":"efficiency/#unit-10-leveling-up-your-productivity-with-cli","text":"","title":"Unit 10: Leveling Up Your Productivity with CLI"},{"location":"efficiency/#minimizing-hand-movements","text":"In Day 1 of the workshop, you have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. You do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type.","title":"Minimizing Hand Movements"},{"location":"efficiency/#minimizing-typing","text":"We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use ++control-p++ or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivity, if you are keen, take a look here: https://github.com/fliptheweb/bash-shortcuts-cheat-sheet You have also seen in Day 1 of the workshop that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for the shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: $ bash hello.sh hello! or $ bash < hello.sh hello! Recall that we said Unix shells do not necessarily interact with the users? This is an example. We pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions unit that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: $ chmod u+x hello.sh $ ./hello.sh hello! Now we can run our script without typing bash . We can remove ./ as well, but we will learn about that only when we talk about environment variables . The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"Minimizing Typing"},{"location":"extra/","text":"Additional Resources Courses Elsewhere The Missing Semester of Your CS Education Great Practical Ideas in CS at CMU The Unix Shell by the Software Carpentry Foundation. The Vim Editor: Philosophy, Principles and Practice at CMU Computerphile on YouTube: History of Unix Mainframes and the Unix Revolution Unix Pipeline Command Line Gems commandlinefu Vim Tutorials Vim: Precision Editing at the Speed of Thought : A talk by Drew Neil Vim Adventure : An adventure game for learning vim Vim Casts : Videos and articles for teaching vim Vim Video Tutorials by Derek Wyatt Vim Awesome : Directory of plugins. Vim Articles Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \" once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards. \"","title":"Extra"},{"location":"extra/#additional-resources","text":"","title":"Additional Resources"},{"location":"extra/#courses-elsewhere","text":"The Missing Semester of Your CS Education Great Practical Ideas in CS at CMU The Unix Shell by the Software Carpentry Foundation. The Vim Editor: Philosophy, Principles and Practice at CMU","title":"Courses Elsewhere"},{"location":"extra/#computerphile-on-youtube-history-of-unix","text":"Mainframes and the Unix Revolution Unix Pipeline","title":"Computerphile on YouTube: History of Unix"},{"location":"extra/#command-line-gems","text":"commandlinefu","title":"Command Line Gems"},{"location":"extra/#vim-tutorials","text":"Vim: Precision Editing at the Speed of Thought : A talk by Drew Neil Vim Adventure : An adventure game for learning vim Vim Casts : Videos and articles for teaching vim Vim Video Tutorials by Derek Wyatt Vim Awesome : Directory of plugins.","title":"Vim Tutorials"},{"location":"extra/#vim-articles","text":"Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \" once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards. \"","title":"Vim Articles"},{"location":"file-management/","text":"Unit 5: Unix File Management This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. $ ls test.txt cp : CoPy files Now let's try to copy this file to another name. $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning. mv : MoVe or rename files Now, let's change directory back to workshop . $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. mv comes with a -i flag that interactively asks you if you are sure if you want to overwrite a file. It is a good idea to always run mv -i . Hit Y to continue overwriting the existing file. We will see how to make -i the default tomorrow ( sneak peak here ). Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command. rm : ReMove files We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively. cat : CATenate file content to screen To quickly take a look at the content of the file, use the cat command. $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Other Useful Online Tools explainshell explain each shell command for you","title":"5. File Management"},{"location":"file-management/#unit-5-unix-file-management","text":"This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. $ ls test.txt","title":"Unit 5: Unix File Management"},{"location":"file-management/#cp-copy-files","text":"Now let's try to copy this file to another name. $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning.","title":"cp: CoPy files"},{"location":"file-management/#mv-move-or-rename-files","text":"Now, let's change directory back to workshop . $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. mv comes with a -i flag that interactively asks you if you are sure if you want to overwrite a file. It is a good idea to always run mv -i . Hit Y to continue overwriting the existing file. We will see how to make -i the default tomorrow ( sneak peak here ). Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.","title":"mv: MoVe or rename files"},{"location":"file-management/#rm-remove-files","text":"We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively.","title":"rm: ReMove files"},{"location":"file-management/#cat-catenate-file-content-to-screen","text":"To quickly take a look at the content of the file, use the cat command. $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to screen"},{"location":"file-management/#man-online-manual","text":"An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q .","title":"man: Online MANual"},{"location":"file-management/#other-useful-online-tools","text":"explainshell explain each shell command for you","title":"Other Useful Online Tools"},{"location":"mac/","text":"Setting Up Unix Computing Environment on macOS macOS is a Unix-based operating system. Not setup is required. To access the Unix command line interface, hit F4 to access LaunchPad, and type Terminal followed by Enter . Install Command Line Development Tool Run xcode-select --install to install a set of command-line tools used for software development in macOS. Install Homebrew Homebrew is a command-line software manager for macOS. If you have not installed Homebrew before, paste the following into your shell to install it. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \"","title":"Setup for macOS"},{"location":"mac/#setting-up-unix-computing-environment-on-macos","text":"macOS is a Unix-based operating system. Not setup is required. To access the Unix command line interface, hit F4 to access LaunchPad, and type Terminal followed by Enter .","title":"Setting Up Unix Computing Environment on macOS"},{"location":"mac/#install-command-line-development-tool","text":"Run xcode-select --install to install a set of command-line tools used for software development in macOS.","title":"Install Command Line Development Tool"},{"location":"mac/#install-homebrew","text":"Homebrew is a command-line software manager for macOS. If you have not installed Homebrew before, paste the following into your shell to install it. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \"","title":"Install Homebrew"},{"location":"path-nav/","text":"Unit 4: Unix Directory Structure and Navigation Unix Directory Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know. Root Directory The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify. Home Directory Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob . Current Working Directory A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash . Parent Directory The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory Specifying a Path To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path . Absolute path The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~ Relative path The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / . Directory-related Commands Now, let's take a look at some basic commands available in bash that deals with navigation and directories. pwd : Print Current Working directory pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering pwd will give the output /home/o/ooiwt ls : LiSt content of a directory The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command. cd : Change Directory To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in the Introduction to Shell unit, it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory. rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command $ rmdir workshop will remove the directory that you just created. In computing, trees are upside down with the root at the top and leaves at the bottom! \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"4. Path and Navigation"},{"location":"path-nav/#unit-4-unix-directory-structure-and-navigation","text":"","title":"Unit 4: Unix Directory Structure and Navigation"},{"location":"path-nav/#unix-directory","text":"Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know.","title":"Unix Directory"},{"location":"path-nav/#root-directory","text":"The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify.","title":"Root Directory"},{"location":"path-nav/#home-directory","text":"Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob .","title":"Home Directory"},{"location":"path-nav/#current-working-directory","text":"A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash .","title":"Current Working Directory"},{"location":"path-nav/#parent-directory","text":"The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory","title":"Parent Directory"},{"location":"path-nav/#specifying-a-path","text":"To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path .","title":"Specifying a Path"},{"location":"path-nav/#absolute-path","text":"The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~","title":"Absolute path"},{"location":"path-nav/#relative-path","text":"The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / .","title":"Relative path"},{"location":"path-nav/#directory-related-commands","text":"Now, let's take a look at some basic commands available in bash that deals with navigation and directories.","title":"Directory-related Commands"},{"location":"path-nav/#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering pwd will give the output /home/o/ooiwt","title":"pwd: Print Current Working directory"},{"location":"path-nav/#ls-list-content-of-a-directory","text":"The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")","title":"ls: LiSt content of a directory"},{"location":"path-nav/#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command.","title":"mkdir: MaKe a subDIRectory"},{"location":"path-nav/#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in the Introduction to Shell unit, it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory.","title":"cd: Change Directory"},{"location":"path-nav/#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command $ rmdir workshop will remove the directory that you just created. In computing, trees are upside down with the root at the top and leaves at the bottom! \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"rmdir: ReMove a subDIRectory"},{"location":"pattern/","text":"Unit 9: Pattern Matching in bash We now show you another productivity shortcut. In an example earlier , you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of $ cat test.txt foo.txt bar.txt | wc We could just run $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , . Example 1: $ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt . Example 2: $ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t . Example 3: $ ls {fo,ba}??txt foo.txt test.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt .","title":"9. Pattern Matching"},{"location":"pattern/#unit-9-pattern-matching-in-bash","text":"We now show you another productivity shortcut. In an example earlier , you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of $ cat test.txt foo.txt bar.txt | wc We could just run $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , .","title":"Unit 9: Pattern Matching in bash"},{"location":"pattern/#example-1","text":"$ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt .","title":"Example 1:"},{"location":"pattern/#example-2","text":"$ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t .","title":"Example 2:"},{"location":"pattern/#example-3","text":"$ ls {fo,ba}??txt foo.txt test.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt .","title":"Example 3:"},{"location":"pipe/","text":"Unit 8: Composing Programs with | Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting. Useful Utilities Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix. head and tail head and tail prints out the first k k lines and last k k lines from a file (or standard input if the file name is not given). By default, k k is 10, but you can pass in an argument to specify k k . $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands. echo echo simply prints out the command-line argument to the standard output. $ echo \"hello world!\" hello world! sort sort rearrange the input lines in alphabetical order. $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order. uniq uniq remove any two consecutive lines that are the same. $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.` grep grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done. Pipe Example To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: $ cat ID | sort | uniq | grep CEG | wc -l 3","title":"8. Composition with Pipe"},{"location":"pipe/#unit-8-composing-programs-with","text":"Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting.","title":"Unit 8: Composing Programs with |"},{"location":"pipe/#useful-utilities","text":"Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix.","title":"Useful Utilities"},{"location":"pipe/#head-and-tail","text":"head and tail prints out the first k k lines and last k k lines from a file (or standard input if the file name is not given). By default, k k is 10, but you can pass in an argument to specify k k . $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands.","title":"head and tail"},{"location":"pipe/#echo","text":"echo simply prints out the command-line argument to the standard output. $ echo \"hello world!\" hello world!","title":"echo"},{"location":"pipe/#sort","text":"sort rearrange the input lines in alphabetical order. $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order.","title":"sort"},{"location":"pipe/#uniq","text":"uniq remove any two consecutive lines that are the same. $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.`","title":"uniq"},{"location":"pipe/#grep","text":"grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done.","title":"grep"},{"location":"pipe/#pipe-example","text":"To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: $ cat ID | sort | uniq | grep CEG | wc -l 3","title":"Pipe Example"},{"location":"schedule/","text":"Tentative Schedule for Unix@Home Workshop (Note: Allocated time is a very rough approxmiate) Day 1 Plenary Session 1: Introduction (20 minutes) 1: What is Unix? Why are we learning/using Unix? 2: What is CLI? Why are we learning/using CLI? 3: What is a terminal? What is a shell? Breakout Session 2: Basic Unix Files Operations I (30 minutes) Setup a Unix computing environment on Windows 10 or macOS Installing tmate for terminal sharing 4: Directories, paths, and navigation Break (20 minutes) Breakout Session 3: Basic Unix Files Operations II (20 minutes) 5: File management 6: Permission management Break (20 minutes) Breakout Session 4: Composition (30 minutes) 7: Standard I/O 8: Piping 9: Pattern Matching DAY 2 Plenary Session 5: Gaining Efficiency with Unix (20 minutes) 10: Producitivity with Unix 11: The philosophy and power of vim Breakout Session 5: Simple file editing with vim (30 minutes) 12: Hands-on with vim Break (20 minutes) Breakout Session 6: Very Basic Shell Scripts (30 minutes) 13: Bash Configuration and Scripting Break (20 minutes) Breakout Session 8: Remote Servers (20 minutes) 14: Accessing Remote Servers Break (20 minutes) Plenary Session 9: Conclusion (10 minutes)","title":"Schedule"},{"location":"schedule/#tentative-schedule-for-unixhome-workshop","text":"(Note: Allocated time is a very rough approxmiate)","title":"Tentative Schedule for Unix@Home Workshop"},{"location":"schedule/#day-1","text":"","title":"Day 1"},{"location":"schedule/#plenary-session-1-introduction-20-minutes","text":"1: What is Unix? Why are we learning/using Unix? 2: What is CLI? Why are we learning/using CLI? 3: What is a terminal? What is a shell?","title":"Plenary Session 1: Introduction (20 minutes)"},{"location":"schedule/#breakout-session-2-basic-unix-files-operations-i-30-minutes","text":"Setup a Unix computing environment on Windows 10 or macOS Installing tmate for terminal sharing 4: Directories, paths, and navigation","title":"Breakout Session 2: Basic Unix Files Operations I (30 minutes)"},{"location":"schedule/#break-20-minutes","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-3-basic-unix-files-operations-ii-20-minutes","text":"5: File management 6: Permission management","title":"Breakout Session 3:  Basic Unix Files Operations II (20 minutes)"},{"location":"schedule/#break-20-minutes_1","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-4-composition-30-minutes","text":"7: Standard I/O 8: Piping 9: Pattern Matching","title":"Breakout Session 4: Composition (30 minutes)"},{"location":"schedule/#day-2","text":"","title":"DAY 2"},{"location":"schedule/#plenary-session-5-gaining-efficiency-with-unix-20-minutes","text":"10: Producitivity with Unix 11: The philosophy and power of vim","title":"Plenary Session 5: Gaining Efficiency with Unix (20 minutes)"},{"location":"schedule/#breakout-session-5-simple-file-editing-with-vim-30-minutes","text":"12: Hands-on with vim","title":"Breakout Session 5: Simple file editing with vim (30 minutes)"},{"location":"schedule/#break-20-minutes_2","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-6-very-basic-shell-scripts-30-minutes","text":"13: Bash Configuration and Scripting","title":"Breakout Session 6: Very Basic Shell Scripts (30 minutes)"},{"location":"schedule/#break-20-minutes_3","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-8-remote-servers-20-minutes","text":"14: Accessing Remote Servers","title":"Breakout Session 8: Remote Servers (20 minutes)"},{"location":"schedule/#break-20-minutes_4","text":"","title":"Break (20 minutes)"},{"location":"schedule/#plenary-session-9-conclusion-10-minutes","text":"","title":"Plenary Session 9: Conclusion (10 minutes)"},{"location":"script/","text":"Unit 13: bash Scripts Now that we know the basic of text editing, we will start writing some simple bash scripts. .bashrc First, let's write a bash script that will be executed every time we run bash. Just like .vimrc , the \"run commands\" for bash is called .bashrc . Recall that the rc files should be hidden and located in the home directory. So, start vim by $ vim ~/.bashrc and add the following lines at the bottom of .bashrc . alias rm=\"rm -i\" alias mv=\"mv -i\" alias cp=\"cp -i\" echo \".bashrc loaded\" If your .bashrc already contains some text, leave the existing text there. Otherwise, you will see a splash screen about vim . Just to into INSERT more to get rid of the splash screen. Remember that the -i flag causes these commands to interact with you and ask to confirm whether you want to remove/override a file. The alias command is used to create a new command. Here, alias rm=\"rm -i\" creates a new command called rm that does perform rm -i . So now, every time you type rm in bash , bash will run your rm , which is just rm -i (the second rm is bash 's rm ). Go ahead and hit Shift + Z + Z to save and quit. Now, exit bash and reload bash again. You should see the message .bashrc loaded printed. Try to create a dummy file and remove it. bash should now prompt you for confirmation. $ touch dummy $ rm dummy remove dummy? You can hit Y for yes or N for no. Bash Environment Variables In addition to creating your customized commands, you can also affect the behavior of bash by configuring its environment variables. An environment variable is something that can hold a value (just like x x <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x in math). The naming convention for an environment variable is to use all upper cases. The most common ones used are: PATH : which is where bash would search for a command to execute. PS1 : which allows you to customize your command prompt. EDITOR : which allows you to configure the default text editor. For PS1 configuration, there are many neat examples on the Internet. We recommend that you should least have your identity displayed somewhere on the command prompt so that the tutors know which terminal they are looking at via tmate . For EDITOR , you can set it to vim . Remember that earlier, to run hello.sh , we needed to include the prefix ./hello.sh ? The ./ is to tell bash to look for the executable in the current directory. To avoid typing ./ all the time (remember our goal: minimize finger movement), we can add . to the PATH . Now, cd into the directory where you have hello.sh , and type $ echo $PATH $ export PATH=$PATH:. $ echo $PATH The first command shows you what the current PATH variable contains. The $ sign refers to the value of that variable instead of the variable name. The PATH contains a list of paths in the directory structure, separated by : . In the second line, we add . (the current directory) to the PATH variable. The third line checks if . is added correctly. If . is indeed added to the path, you can now run hello.sh without the prefix ./ . Note that there is a security risk in adding . to PATH . My recommendation is only to do it on your personal Unix system (not a shared computing server) and add . only at the end of PATH . See this FAQ for more information. If you wish, you can now edit this line into .bashrc , so that it is executed every time you launch `bash. export PATH=$PATH:. Simple Bash Scripts In addition to creating aliases, you can put commonly used commands in a bash script. The advantage is that it allows us to pass in arguments so that the script is more flexible. For instance, the following script finds out the size of a directory and the size of the largest subdirectory (in MBs) #!/bin/bash du -m $1 | sort -n | tail -2 You can read the man pages for what du , sort , and tail and the various options do. But the two interesting points we wish to point out are the first line: #!/bin/bash and the variable $1 . The #! sequence is called shebang . It is used by Unix to determine which interpreter to use to run this script. It could be replaced with /usr/bin/python or other language interpreters, for instance. But here, we meant this to be a bash script so we tell Unix to invoke bash . The variable $1 will be replaced by the argument passed into the script on the command line. Suppose that we save the script above as dirsize.sh . Then you run: dirsize.sh /usr/local $1 will become /usr/local and so the size of /usr/local and its subdirectories will be determined. If you do not pass in any argument, $1 will be empty, and the size of the current working directory will be determined instead. Developing an Automation Mind Set If you find yourself typing the same command or sequence of commands over and over again, it is probably good to start creating a script to automate it. You will need to invest some time upfront to get the script written and tested, but in the long run, it will save you time.","title":"13. Bash Scripting"},{"location":"script/#unit-13-bash-scripts","text":"Now that we know the basic of text editing, we will start writing some simple bash scripts.","title":"Unit 13: bash Scripts"},{"location":"script/#bashrc","text":"First, let's write a bash script that will be executed every time we run bash. Just like .vimrc , the \"run commands\" for bash is called .bashrc . Recall that the rc files should be hidden and located in the home directory. So, start vim by $ vim ~/.bashrc and add the following lines at the bottom of .bashrc . alias rm=\"rm -i\" alias mv=\"mv -i\" alias cp=\"cp -i\" echo \".bashrc loaded\" If your .bashrc already contains some text, leave the existing text there. Otherwise, you will see a splash screen about vim . Just to into INSERT more to get rid of the splash screen. Remember that the -i flag causes these commands to interact with you and ask to confirm whether you want to remove/override a file. The alias command is used to create a new command. Here, alias rm=\"rm -i\" creates a new command called rm that does perform rm -i . So now, every time you type rm in bash , bash will run your rm , which is just rm -i (the second rm is bash 's rm ). Go ahead and hit Shift + Z + Z to save and quit. Now, exit bash and reload bash again. You should see the message .bashrc loaded printed. Try to create a dummy file and remove it. bash should now prompt you for confirmation. $ touch dummy $ rm dummy remove dummy? You can hit Y for yes or N for no.","title":".bashrc"},{"location":"script/#bash-environment-variables","text":"In addition to creating your customized commands, you can also affect the behavior of bash by configuring its environment variables. An environment variable is something that can hold a value (just like x x <span><span class=\"MathJax_Preview\">x</span><script type=\"math/tex\">x in math). The naming convention for an environment variable is to use all upper cases. The most common ones used are: PATH : which is where bash would search for a command to execute. PS1 : which allows you to customize your command prompt. EDITOR : which allows you to configure the default text editor. For PS1 configuration, there are many neat examples on the Internet. We recommend that you should least have your identity displayed somewhere on the command prompt so that the tutors know which terminal they are looking at via tmate . For EDITOR , you can set it to vim . Remember that earlier, to run hello.sh , we needed to include the prefix ./hello.sh ? The ./ is to tell bash to look for the executable in the current directory. To avoid typing ./ all the time (remember our goal: minimize finger movement), we can add . to the PATH . Now, cd into the directory where you have hello.sh , and type $ echo $PATH $ export PATH=$PATH:. $ echo $PATH The first command shows you what the current PATH variable contains. The $ sign refers to the value of that variable instead of the variable name. The PATH contains a list of paths in the directory structure, separated by : . In the second line, we add . (the current directory) to the PATH variable. The third line checks if . is added correctly. If . is indeed added to the path, you can now run hello.sh without the prefix ./ . Note that there is a security risk in adding . to PATH . My recommendation is only to do it on your personal Unix system (not a shared computing server) and add . only at the end of PATH . See this FAQ for more information. If you wish, you can now edit this line into .bashrc , so that it is executed every time you launch `bash. export PATH=$PATH:.","title":"Bash Environment Variables"},{"location":"script/#simple-bash-scripts","text":"In addition to creating aliases, you can put commonly used commands in a bash script. The advantage is that it allows us to pass in arguments so that the script is more flexible. For instance, the following script finds out the size of a directory and the size of the largest subdirectory (in MBs) #!/bin/bash du -m $1 | sort -n | tail -2 You can read the man pages for what du , sort , and tail and the various options do. But the two interesting points we wish to point out are the first line: #!/bin/bash and the variable $1 . The #! sequence is called shebang . It is used by Unix to determine which interpreter to use to run this script. It could be replaced with /usr/bin/python or other language interpreters, for instance. But here, we meant this to be a bash script so we tell Unix to invoke bash . The variable $1 will be replaced by the argument passed into the script on the command line. Suppose that we save the script above as dirsize.sh . Then you run: dirsize.sh /usr/local $1 will become /usr/local and so the size of /usr/local and its subdirectories will be determined. If you do not pass in any argument, $1 will be empty, and the size of the current working directory will be determined instead.","title":"Simple Bash Scripts"},{"location":"script/#developing-an-automation-mind-set","text":"If you find yourself typing the same command or sequence of commands over and over again, it is probably good to start creating a script to automate it. You will need to invest some time upfront to get the script written and tested, but in the long run, it will save you time.","title":"Developing an Automation Mind Set"},{"location":"shell/","text":"Unit 3: Terminal and Shell What is a Terminal? With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence. What is a Shell? The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. I (Wei Tsang) personally use fish for my day-to-day work. Oh-my-zsh ( zsh ) is another shell popular among experienced users. Command Prompt A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell. Terminal Control Sequence On the old teletype machines (see history of command-line interfaces ), a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this contorl sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal.","title":"3. Terminal and Shell"},{"location":"shell/#unit-3-terminal-and-shell","text":"","title":"Unit 3: Terminal and Shell"},{"location":"shell/#what-is-a-terminal","text":"With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence.","title":"What is a Terminal?"},{"location":"shell/#what-is-a-shell","text":"The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. I (Wei Tsang) personally use fish for my day-to-day work. Oh-my-zsh ( zsh ) is another shell popular among experienced users.","title":"What is a Shell?"},{"location":"shell/#command-prompt","text":"A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell.","title":"Command Prompt"},{"location":"shell/#terminal-control-sequence","text":"On the old teletype machines (see history of command-line interfaces ), a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this contorl sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal.","title":"Terminal Control Sequence"},{"location":"ssh/","text":"Accessing Remote Shell So far, we have been accessing the Unix computing environment locally, on your laptop or desktop computer. Using the shell, however, opens up a whole new world -- you can now access a remote computer over the Internet using the same interface. Let's try this out, using one of the two remote servers: sunfire A Unix computing server called sunfire , hosted by the School of Computing. To access this, you need to have a SoC Unix Account. If you do not have one yet, you can create a new account here: https://mysoc.nus.edu.sg/~newacct After that, activate \"General Unix Servers\" and \"The SoC Compute Cluster\" in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi sunfire is a shared machine running Solaris. To log into sunfire , type: $ ssh sunfire.comp.nus.edu.sg or $ ssh <username>@sunfire.comp.nus.edu.sg The first option above assumes your SoC Unix account name is the same as your username on your local machine (Remember we advised you to choose the same username when you installed WSL? This is why!). In the second option, we have to explicitly provide our user name. For instance, $ ssh ooiwt@sunfire.comp.nus.edu.sg These commands are too long to type so you could add an alias for this command into your ~/.bashrc . sdf.org For those students who do not have a NUSNET or SoC account, as a backup, you can apply for an account at public access Unix system provided by the Super Dimension Fortress at http://www.sdf.org . Once you receive your account, you can ssh into sdf.org by $ ssh sdf.org Secure Shell ssh stands for secure shell. It is called secure as it encrypts all communications between you and the remote server. It is an efficient way to access a remote computer since only texts are transmitted, not graphics. The first time you access a remote computer using ssh , it will ask you a question, which looks sometimes like this: The authenticity of host 'sunfire (137.132.80.55)' can't be established. RSA key fingerprint is SHA256:UUyiI25neTV5AT/q3CJi0BAA4ztfo+7doi77bkzpLJ4. Are you sure you want to continue connecting (yes/no/[fingerprint])? Type yes then hit Enter . You won't be asked the same question again. Once you log in, you will be presented the same interface as you are used to -- a command prompt. You can do everything that you have learned at this command prompt, with the only difference being you are doing it on a remote computer (aka remote host or remote server ). Transferring Files Back and Forth Secure copy, or scp , is one way to transfer files between the remote host and your local computer for archiving or storage. Let's say you want to transfer jfk.txt from the current working directory to your remote directory, then, on your local computer, run: $ scp jfk.txt sunfire.comp.nus.edu.sg:~/ scp behaves just like cp , except that we add sunfire.comp.nus.edu.sg: in front of a path (add <username>@ as necessary) to indicate the name of the remote host to copy the files to. The path ~/ now refers to the home directory on the remote host. If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . scp supports -r (recursive copy) as well.","title":"14. Remote Servers"},{"location":"ssh/#accessing-remote-shell","text":"So far, we have been accessing the Unix computing environment locally, on your laptop or desktop computer. Using the shell, however, opens up a whole new world -- you can now access a remote computer over the Internet using the same interface. Let's try this out, using one of the two remote servers:","title":"Accessing Remote Shell"},{"location":"ssh/#sunfire","text":"A Unix computing server called sunfire , hosted by the School of Computing. To access this, you need to have a SoC Unix Account. If you do not have one yet, you can create a new account here: https://mysoc.nus.edu.sg/~newacct After that, activate \"General Unix Servers\" and \"The SoC Compute Cluster\" in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi sunfire is a shared machine running Solaris. To log into sunfire , type: $ ssh sunfire.comp.nus.edu.sg or $ ssh <username>@sunfire.comp.nus.edu.sg The first option above assumes your SoC Unix account name is the same as your username on your local machine (Remember we advised you to choose the same username when you installed WSL? This is why!). In the second option, we have to explicitly provide our user name. For instance, $ ssh ooiwt@sunfire.comp.nus.edu.sg These commands are too long to type so you could add an alias for this command into your ~/.bashrc .","title":"sunfire"},{"location":"ssh/#sdforg","text":"For those students who do not have a NUSNET or SoC account, as a backup, you can apply for an account at public access Unix system provided by the Super Dimension Fortress at http://www.sdf.org . Once you receive your account, you can ssh into sdf.org by $ ssh sdf.org","title":"sdf.org"},{"location":"ssh/#secure-shell","text":"ssh stands for secure shell. It is called secure as it encrypts all communications between you and the remote server. It is an efficient way to access a remote computer since only texts are transmitted, not graphics. The first time you access a remote computer using ssh , it will ask you a question, which looks sometimes like this: The authenticity of host 'sunfire (137.132.80.55)' can't be established. RSA key fingerprint is SHA256:UUyiI25neTV5AT/q3CJi0BAA4ztfo+7doi77bkzpLJ4. Are you sure you want to continue connecting (yes/no/[fingerprint])? Type yes then hit Enter . You won't be asked the same question again. Once you log in, you will be presented the same interface as you are used to -- a command prompt. You can do everything that you have learned at this command prompt, with the only difference being you are doing it on a remote computer (aka remote host or remote server ).","title":"Secure Shell"},{"location":"ssh/#transferring-files-back-and-forth","text":"Secure copy, or scp , is one way to transfer files between the remote host and your local computer for archiving or storage. Let's say you want to transfer jfk.txt from the current working directory to your remote directory, then, on your local computer, run: $ scp jfk.txt sunfire.comp.nus.edu.sg:~/ scp behaves just like cp , except that we add sunfire.comp.nus.edu.sg: in front of a path (add <username>@ as necessary) to indicate the name of the remote host to copy the files to. The path ~/ now refers to the home directory on the remote host. If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . scp supports -r (recursive copy) as well.","title":"Transferring Files Back and Forth"},{"location":"stdio/","text":"Unit 7: Standard Input/Output History Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal . Examples using cat and wc Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered. Output Redirection By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt Input Redirection The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator.","title":"7. Standard I/O"},{"location":"stdio/#unit-7-standard-inputoutput","text":"","title":"Unit 7: Standard Input/Output"},{"location":"stdio/#history","text":"Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal .","title":"History"},{"location":"stdio/#examples-using-cat-and-wc","text":"Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered.","title":"Examples using cat and wc"},{"location":"stdio/#output-redirection","text":"By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt","title":"Output Redirection"},{"location":"stdio/#input-redirection","text":"The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator.","title":"Input Redirection"},{"location":"tmate/","text":"Setting Up tmate Before you continue, read about what is a terminal . Make sure you have set up apt if you use WSL and brew if you use macOS. What is tmate ? tmate is a tool that allows you to share your terminal with others. This allows another person to have enter text into your terminal and to see the output returned by your terminal. We will use tmate to allow tutors to view and type into your terminal. Giving someone else full control of your computer is dangerous -- so you need to be sure that you are sharing your terminal with someone you trust (e.g., your professor and your tutor). Do NOT share your tmate link publicly. Installing tmate on WSL or Ubuntu Run the following in your terminal: sudo apt install tmate Installing tmate on macOS Run the following in your terminal: brew install tmate Running tmate To share your screen with someone you trust, run: tmate You should then see the following messages: Tip: if you wish to use tmate only for remote access, run: tmate -F [0/0] To see the following messages again, run in a tmate session: tmate show-messages Press <q> or <ctrl-c> to continue --------------------------------------------------------------------- Connecting to ssh.tmate.io... Note: clear your terminal before sharing readonly access web session read only: https://tmate.io/t/ro-Zv6kbZxwLtc84NXnnFJtGvnYE ssh session read only: ssh ro-Zv6kbZxwLtc84NXnnFJtGvnYE@sgp1.tmate.io web session: https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ssh session: ssh 3svwMBrjhwgp93QmZFHLnwzRP@sgp1.tmate.io Note that your output will not be exactly the same as the above, particular, the seemingly gibberish text is randomly generated when you run tmate , so it will be a different gibberish every time. There are several important piece of information here: There are a list of links for you to share with your tutors. Suppose your tutor wants to see (but not control) your screen through a web browser, you can send the link marked as web session read only: to him or her (e.g., via private chat in Zoom). If your tutor needs to show you something on your shell through a web browser, you can send the link marked as web session: to him or her. (In the example above: send https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ) If you do not copy down the links and need to access them later, just run tmate show-messages . Note that the links are randomly generated and are different every time you run tmate . Once you have copied and send the link to your tutor, press Q or Ctrl + C to continue. Your terminal is now shared with your tutor. You can tell this as there is a small bar at the bottom of your terminal's screen. To stop sharing, hit Ctrl + D at the command prompt 1 . Here is a small screencast to demonstrate this: For an overview of all special terminal Ctrl commands, see terminal control sequence . \u21a9","title":"Setup tmate"},{"location":"tmate/#setting-up-tmate","text":"Before you continue, read about what is a terminal . Make sure you have set up apt if you use WSL and brew if you use macOS.","title":"Setting Up tmate"},{"location":"tmate/#what-is-tmate","text":"tmate is a tool that allows you to share your terminal with others. This allows another person to have enter text into your terminal and to see the output returned by your terminal. We will use tmate to allow tutors to view and type into your terminal. Giving someone else full control of your computer is dangerous -- so you need to be sure that you are sharing your terminal with someone you trust (e.g., your professor and your tutor). Do NOT share your tmate link publicly.","title":"What is tmate?"},{"location":"tmate/#installing-tmate-on-wsl-or-ubuntu","text":"Run the following in your terminal: sudo apt install tmate","title":"Installing tmate on WSL or Ubuntu"},{"location":"tmate/#installing-tmate-on-macos","text":"Run the following in your terminal: brew install tmate","title":"Installing tmate on macOS"},{"location":"tmate/#running-tmate","text":"To share your screen with someone you trust, run: tmate You should then see the following messages: Tip: if you wish to use tmate only for remote access, run: tmate -F [0/0] To see the following messages again, run in a tmate session: tmate show-messages Press <q> or <ctrl-c> to continue --------------------------------------------------------------------- Connecting to ssh.tmate.io... Note: clear your terminal before sharing readonly access web session read only: https://tmate.io/t/ro-Zv6kbZxwLtc84NXnnFJtGvnYE ssh session read only: ssh ro-Zv6kbZxwLtc84NXnnFJtGvnYE@sgp1.tmate.io web session: https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ssh session: ssh 3svwMBrjhwgp93QmZFHLnwzRP@sgp1.tmate.io Note that your output will not be exactly the same as the above, particular, the seemingly gibberish text is randomly generated when you run tmate , so it will be a different gibberish every time. There are several important piece of information here: There are a list of links for you to share with your tutors. Suppose your tutor wants to see (but not control) your screen through a web browser, you can send the link marked as web session read only: to him or her (e.g., via private chat in Zoom). If your tutor needs to show you something on your shell through a web browser, you can send the link marked as web session: to him or her. (In the example above: send https://tmate.io/t/3svwMBrjhwgp93QmZFHLnwzRP ) If you do not copy down the links and need to access them later, just run tmate show-messages . Note that the links are randomly generated and are different every time you run tmate . Once you have copied and send the link to your tutor, press Q or Ctrl + C to continue. Your terminal is now shared with your tutor. You can tell this as there is a small bar at the bottom of your terminal's screen. To stop sharing, hit Ctrl + D at the command prompt 1 . Here is a small screencast to demonstrate this: For an overview of all special terminal Ctrl commands, see terminal control sequence . \u21a9","title":"Running tmate"},{"location":"vim-intro/","text":"Unit 11: Terminal-based Editor: vim The above examples show us how we can create a simple, one-line, shell script. Shell scripts can be fairly complex -- bash supports a full-blown programming language. To edit shell scripts, programs, or text files, we need a proper editor. Remember that we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys. There are only two respectable, widely available text editors in Unix -- vim and emacs , which one is better has been an ongoing religious war, but for us in SoC, we use vim . You will get to practice using vim in the next session, but for a start, I will go through the key ideas of vim . 1. Minimizing Hand Movements vim , like the shell, aims to minimize hand movements. Frequently used commands are positioned in convenient places on the keyboard. Let me give you a few examples. To exit vim, type Shift + Z + Z . Notice that this is located at the bottom left corner of your keyboard. For normal typing, your left hand is supposed to be placed over the keys A S D F , so you just need move slightly your left pinky to Shift and left ring finger to Z and hit them. To move the cursor, instead of using the arrow keys, vim uses H to move left, L to move right, J to move down, and K to move up. For normal typing, you right hand is supposed to be placed on J K L ; , so these arrow keys alternatives are located very near to where your right hand should be! I have a few more things to say about using H J K L to replace the arrow keys: It is not uncommon for applications to re-map other keys for movement. Many first-person shooting games uses W A S D for movement, for the same reason as vim -- it is close to the resting position of the left hand on the keyboard. The use of H J K L for movement is more ubiquitous than you think. In the Web-version of Facebook and Reddit, for instance, you can use J and K to move up and down across posts. On this website, you can use H and L to go to the previous page and the next page respectively. 2. Multi-modal Editor vim is a multi-modal editor. While for most other editors makes no distinction between reading and editing, vim makes an explicit distinction between the two. vim has two basic modes: NORMAL mode: where you read, navigate and manipulate the text. INSERT mode: where you insert the text As a programmer, having a different NORMAL modes makes sense since we spend much time reading and navigating around source code. Thus, allowing the editing commands to optimized. In the NORMAL mode, you can use any of these keys I S A O (with or without Shift ) to switch to INSERT mode. To go back to NORMAL mode, press Esc . The keys I S A O have different meanings, which you will learn later. Note that most of the time you will be in NORMAL mode. So a habitual vim users would insert some text and immediately switch back to normal mode by hitting Esc . 3. Tell vim What You Want To Do; Don't Do It Yourself In NORMAL mode, you can manipulate text in vim by issuing commands to vim . These commands are like a programming language. It is also not unlike the Unix commands, in that each command does a small thing but can be composed together to perform complex text manipulation. Let me give an example here. Suppose you have a sentence: Wherever there is light, there is also a shadow. You want to remove also a from the sentence. What would you do in a typical text editor? You can use move your hand away from the keyboard, find your mouse, move your mouse cursor to highlight the text, and then hit Del . Or you could move the cursor (by mouse or by repeatedly hitting the keyboard) to place the cursor after a , and then press Del six times. In addition to being tedious, this is error-prone. You might highlight one additional or one less space, or hit Del one too many times. What we are used to do is to perform the action of deleting the words ourselves. For vim , we do it differently. We need to look for the word also and delete two words. This translate to the command / A L S O Enter D 2 W . / triggers a search. This is an almost universal command -- try / on Facebook (web) or on this page. A L S O Enter tells vim what you want to search. After enter, your cursor should be placed at the beginning of also . D 2 W tell vim to \"delete two words\". Instead of worrying about the actual actions to perform the deletion, we issue higher-level commands to describe what we want to do. This is powerful since this is how our brain thinks -- \"I need to insert this here, change this word to that, remove two lines, etc\" All these maps into commands in vim . As a result, once you master vim basics, you can type as fast as you think 1 ! A common pattern for vim command consists of three parts: (i) place the cursor; (ii) performance an action; (iii) move to the new placement of the cursor. In the example above, / A L S O Enter places the cursor, D is the action (delete), and 2 W is the movement (move the cursor forward by two words). Another common command that students used is G G = Shift + G . This command is used to indent the source code in the current file. G G is the command to place the cursor at the top of the file. = is the the action (indent), and Shift + G is the command to place the cursor on the last line of the file. 4. Be A Good Unix Citizen Not only the basic commands vim adhere to the Unix principles of composability, vim plays well with Unix shells, which add additional power to the vim . For instance, if you want to have the standard output from a command paste into the file you are editing, you can run: :r! <command> : triggers the vim command line. R ask vim to read something and paste it into the current cursor location. At this point, you can pass in, for instance, another file name. But here, we enter ++exclaim++, which tells vim to run a shell. We then pass the command to the shell. Whatever the command writes to the standard output, will be read and inserted into vim . Want to insert today's date? :r! date Want to insert a mini calendar? :r! cal Want to insert the list of all JPG pictures? :r! ls *jpg You can even pass a chunk of text from vim to the standard input of another program, and replace it with what is printed to the standard output by that program. Other Reasons To Learn vim Besides enabling you to type as fast as you think with as few hand movements as possible, there are other reasons to use vim : vim is installed by default in almost any Unix environment. Imagine if you get called to a client-side to debug a Linux server and you need to edit something -- you can rest assure that vim is there. vim is the only source code editor you need to learn and master. It works for almost any programming language. If you use IDE, you have to learn IntelliJ for Java, IDLE for Python, Visual Studio C++ for C++, etc. vim is extensible and programmable. It has been around for almost 30 years, and tons of plugins have been written. Whatever feature you need, there is likely a native vim command or a vim plugin for that. The only downside to using vim is that it is text-only (some considers it ugly) and the steep learning curve. The book Practical Vim by Drew Neil has the subtitle \"Edit text at the speed of thought\". \u21a9","title":"11. Intro to Vim"},{"location":"vim-intro/#unit-11-terminal-based-editor-vim","text":"The above examples show us how we can create a simple, one-line, shell script. Shell scripts can be fairly complex -- bash supports a full-blown programming language. To edit shell scripts, programs, or text files, we need a proper editor. Remember that we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys. There are only two respectable, widely available text editors in Unix -- vim and emacs , which one is better has been an ongoing religious war, but for us in SoC, we use vim . You will get to practice using vim in the next session, but for a start, I will go through the key ideas of vim .","title":"Unit 11: Terminal-based Editor: vim"},{"location":"vim-intro/#1-minimizing-hand-movements","text":"vim , like the shell, aims to minimize hand movements. Frequently used commands are positioned in convenient places on the keyboard. Let me give you a few examples. To exit vim, type Shift + Z + Z . Notice that this is located at the bottom left corner of your keyboard. For normal typing, your left hand is supposed to be placed over the keys A S D F , so you just need move slightly your left pinky to Shift and left ring finger to Z and hit them. To move the cursor, instead of using the arrow keys, vim uses H to move left, L to move right, J to move down, and K to move up. For normal typing, you right hand is supposed to be placed on J K L ; , so these arrow keys alternatives are located very near to where your right hand should be! I have a few more things to say about using H J K L to replace the arrow keys: It is not uncommon for applications to re-map other keys for movement. Many first-person shooting games uses W A S D for movement, for the same reason as vim -- it is close to the resting position of the left hand on the keyboard. The use of H J K L for movement is more ubiquitous than you think. In the Web-version of Facebook and Reddit, for instance, you can use J and K to move up and down across posts. On this website, you can use H and L to go to the previous page and the next page respectively.","title":"1. Minimizing Hand Movements"},{"location":"vim-intro/#2-multi-modal-editor","text":"vim is a multi-modal editor. While for most other editors makes no distinction between reading and editing, vim makes an explicit distinction between the two. vim has two basic modes: NORMAL mode: where you read, navigate and manipulate the text. INSERT mode: where you insert the text As a programmer, having a different NORMAL modes makes sense since we spend much time reading and navigating around source code. Thus, allowing the editing commands to optimized. In the NORMAL mode, you can use any of these keys I S A O (with or without Shift ) to switch to INSERT mode. To go back to NORMAL mode, press Esc . The keys I S A O have different meanings, which you will learn later. Note that most of the time you will be in NORMAL mode. So a habitual vim users would insert some text and immediately switch back to normal mode by hitting Esc .","title":"2. Multi-modal Editor"},{"location":"vim-intro/#3-tell-vim-what-you-want-to-do-dont-do-it-yourself","text":"In NORMAL mode, you can manipulate text in vim by issuing commands to vim . These commands are like a programming language. It is also not unlike the Unix commands, in that each command does a small thing but can be composed together to perform complex text manipulation. Let me give an example here. Suppose you have a sentence: Wherever there is light, there is also a shadow. You want to remove also a from the sentence. What would you do in a typical text editor? You can use move your hand away from the keyboard, find your mouse, move your mouse cursor to highlight the text, and then hit Del . Or you could move the cursor (by mouse or by repeatedly hitting the keyboard) to place the cursor after a , and then press Del six times. In addition to being tedious, this is error-prone. You might highlight one additional or one less space, or hit Del one too many times. What we are used to do is to perform the action of deleting the words ourselves. For vim , we do it differently. We need to look for the word also and delete two words. This translate to the command / A L S O Enter D 2 W . / triggers a search. This is an almost universal command -- try / on Facebook (web) or on this page. A L S O Enter tells vim what you want to search. After enter, your cursor should be placed at the beginning of also . D 2 W tell vim to \"delete two words\". Instead of worrying about the actual actions to perform the deletion, we issue higher-level commands to describe what we want to do. This is powerful since this is how our brain thinks -- \"I need to insert this here, change this word to that, remove two lines, etc\" All these maps into commands in vim . As a result, once you master vim basics, you can type as fast as you think 1 ! A common pattern for vim command consists of three parts: (i) place the cursor; (ii) performance an action; (iii) move to the new placement of the cursor. In the example above, / A L S O Enter places the cursor, D is the action (delete), and 2 W is the movement (move the cursor forward by two words). Another common command that students used is G G = Shift + G . This command is used to indent the source code in the current file. G G is the command to place the cursor at the top of the file. = is the the action (indent), and Shift + G is the command to place the cursor on the last line of the file.","title":"3. Tell vim What You Want To Do; Don't Do It Yourself"},{"location":"vim-intro/#4-be-a-good-unix-citizen","text":"Not only the basic commands vim adhere to the Unix principles of composability, vim plays well with Unix shells, which add additional power to the vim . For instance, if you want to have the standard output from a command paste into the file you are editing, you can run: :r! <command> : triggers the vim command line. R ask vim to read something and paste it into the current cursor location. At this point, you can pass in, for instance, another file name. But here, we enter ++exclaim++, which tells vim to run a shell. We then pass the command to the shell. Whatever the command writes to the standard output, will be read and inserted into vim . Want to insert today's date? :r! date Want to insert a mini calendar? :r! cal Want to insert the list of all JPG pictures? :r! ls *jpg You can even pass a chunk of text from vim to the standard input of another program, and replace it with what is printed to the standard output by that program.","title":"4. Be A Good Unix Citizen"},{"location":"vim-intro/#other-reasons-to-learn-vim","text":"Besides enabling you to type as fast as you think with as few hand movements as possible, there are other reasons to use vim : vim is installed by default in almost any Unix environment. Imagine if you get called to a client-side to debug a Linux server and you need to edit something -- you can rest assure that vim is there. vim is the only source code editor you need to learn and master. It works for almost any programming language. If you use IDE, you have to learn IntelliJ for Java, IDLE for Python, Visual Studio C++ for C++, etc. vim is extensible and programmable. It has been around for almost 30 years, and tons of plugins have been written. Whatever feature you need, there is likely a native vim command or a vim plugin for that. The only downside to using vim is that it is text-only (some considers it ugly) and the steep learning curve. The book Practical Vim by Drew Neil has the subtitle \"Edit text at the speed of thought\". \u21a9","title":"Other Reasons To Learn vim"},{"location":"vim-practice/","text":"Unit 12: Getting Started with vim Setting Up Your vim Environment Like many other Unix programs, you can configure your preferences by creating an rc (run commands) file in your home directory. These rc files will be read by the corresponding programs and executed line-by-line as if the text is entered into the program through a keyboard. You can view these rc as a script that will be executed automatically whenever a program starts. For vim , the rc file is called .vimrc . The . in the front of the file name carries a special meaning in Unix. It means that this file is hidden -- you won't see it when you ls . Hiding the run command files prevent your home directory from being cluttered. To tell ls to show the hidden files, use the -a flag $ ls -a We have created a .vimrc file, with reasonable defaults, for your use. Note that different modules may choose to use a different coding convention and so a different setting. But this .vimrc file suffices for now. To get this file, $ cd $ mv .vimrc .vimrc.bak $ mkdir .backup $ wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/.vimrc The first line changes your working directory to your home. The second line creates a backup .vimrc , if one exists. If it does not, mv will give you an error, which is fine. The third line creates a hidden backup directory for vim . The last line downloads our .vimrc into your home directory. Our default .vimrc set up vim such that it creates a backup copy of the file you are editing every time and store it in ~/.backup . This feature has saved me from pulling my hair out countless times. It is highly recommended that you set this up whenever you vim . Lesson 1: Navigation Now, you can stay in your home directory or go back to your workshop directory. Download the following file for practice using vim in this session. $ wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/jfk.txt The file named jfk.txt should be downloaded. Now let's start your first vim session. $ vim jfk.txt When you start, you will be in NORMAL mode. For now, just move around the cursor with H J K L . Get comfortable with using the keys. Next, try ( and ) to move forward and backward, sentence-by-sentence. Next, try { and } to move forward and backward, paragraph-by-paragraph. Use 0 to jump to the beginning of the line, and $ to jump to the end of the line. Use G + G to jump to the beginning of the file, and Shift + G ( G ) to jump to the last line of the file. Now try / , type in any word (or prefix of a word) and Enter . This should move the cursor to the beginning of the word. You can use N and P to move to the next match and the previous match. When you are comfortable with moving around, you can Shift + Z + Z to exit. Congratulations, you have just completed your first session in vim ! Lesson 2: Manipulating Text Now, we are going to open up the same file again and try to manipulate the text. We are going to stay in the NORMAL mode still. $ vim jfk.txt Deletion Try 0 D 3 W to move the cursor to the beginning of the line and delete three words. Press U to undo. This is another lifesaver that you should remember. In vim , repeating the same command twice usually means applying it to the whole line. So D D deletes the current line. Try that. Pairing a command with Shift (or the capital letter version) usually means applying the action until the end of the line. So Shift + D deletes from the current cursor until the end of the line. Copy Pasting Hit P to paste back what you just deleted. Try moving the cursor to somewhere else and paste. To copy (or yank) the current line, hit Y Y . Remember that all these commands can be composed using the movement-action-movement pattern. For instance, Shift + 9 Y Shift + 0 , which corresponds to: move to the beginning of the sentence, yank, and until the end of the sentence, basically copy the current sentence. As you have seen in the D 2 W example, you can preceed an action with a number to repeat an action multiple times. Try Y Y 9 P . You should be able to understand what just happened! Deleting a Character The X command deletes the current character. Try this exercise: At the end of the file jfk.txt , there are some typos: libertyi. liberty. Change libertyi. liberty. to libtery. by positioning the cursor on the second i and delete it. Then use Shift + D to delete the extra liberty. at the end of the sentence. Visual Mode In addition to the INSERT and NORMAL modes, vim has the third mode, the VISUAL mode. You can enter the VISUAL mode by hitting V . Once in visual mode, you can move your cursor to select the text and perform some actions on it (e.g., D or X to delete, Y to yank). Hitting Shift + V will allow you to select line-by-line. The VISUAL mode allows us to pipe the selected text to another Unix command, and replace it with the result of that command. Go ahead and try to select a paragraph in jfk.txt , and hit : . You will see that :'<,'> appears in the last line of the terminal. At this point, you can type in actions that you want to perform on the selected text. For instance, :'<,'>w john.txt will write it to a file named john.txt . But, let's try the following: :'<,'>!fmt !fmt tells vim to invoke the shell and run fmt . fmt is another simple small Unix utility that takes in a text (from standard input) and spew out formatted text in the standard output. You will see that the width of the text has changed to the default of 65. You can try something that we have seen before. Reselect the text, and hit :'<,'>!wc The selected text will be replaced with the output from wc . The : command You have seen examples of : commands for writing to a file or piping selected text to an external command. The : command also opens up a large number of actions you can do in vim . Here are a few essential yet simple commands. To jump to a line, hit : followed by the line number. To open another file, hit : and then type in e <filename> To find help on a topic, hit : and then type in help <keyword> Other advanced features such as search-and-replace, changing preferences, splitting windows, opening new tabs, are also accessible from the : command. The : command prompt supports Ctrl + P and Ctrl + N for navigating back and forth your command history, just like bash . It also supports Tab for auto-completion. Lesson 3: Insert mode! Finally, we are going to try inserting some text. Remember, to use INSERT mode, we always start with a command I A O or S (may paired with Shift ) followed by the text that you want to insert, followed by Esc . Let's try I (insert). Place your cursor anywhere, hit I , and start typing, when you are done. Hit Esc . You just added some text to the file. Place your cursor anywhere, hit A (append), and start typing, when you are done. Hit Esc . A appends the text to the end of the current line. Hit O (open) and start typing, when you are done. Hit Esc . O opens up a new line for the your text. Hit S (substitute) and start typing, when you are done. Hit Esc . S substitute the current character with your text. Now try it with Shift and see the difference in behavior. Learning More There is only so much we can cover in 30 minutes. This workshop only covers the tip of the iceberg. To learn more about vim , we suggest that you run vimtutor on the command line and follow through the tutorials. Once you are comfortable, you can soup up your vim with various plugins and learn how to use advanced commands (such as search and replace, jumping between files, recording macros, folding, auto-completion) that are invaluable for programming. There are also many video tutorials and resources online. Some interesting ones are: Vim: Precision Editing at the Speed of Thought : A talk by Drew Neil Vim Adventure : An adventure game for learning vim Vim Casts : Videos and articles for teaching vim Vim Video Tutorials by Derek Wyatt Vim Awesome : Directory of plugins.","title":"12. Hands on with Vim"},{"location":"vim-practice/#unit-12-getting-started-with-vim","text":"","title":"Unit 12: Getting Started with vim"},{"location":"vim-practice/#setting-up-your-vim-environment","text":"Like many other Unix programs, you can configure your preferences by creating an rc (run commands) file in your home directory. These rc files will be read by the corresponding programs and executed line-by-line as if the text is entered into the program through a keyboard. You can view these rc as a script that will be executed automatically whenever a program starts. For vim , the rc file is called .vimrc . The . in the front of the file name carries a special meaning in Unix. It means that this file is hidden -- you won't see it when you ls . Hiding the run command files prevent your home directory from being cluttered. To tell ls to show the hidden files, use the -a flag $ ls -a We have created a .vimrc file, with reasonable defaults, for your use. Note that different modules may choose to use a different coding convention and so a different setting. But this .vimrc file suffices for now. To get this file, $ cd $ mv .vimrc .vimrc.bak $ mkdir .backup $ wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/.vimrc The first line changes your working directory to your home. The second line creates a backup .vimrc , if one exists. If it does not, mv will give you an error, which is fine. The third line creates a hidden backup directory for vim . The last line downloads our .vimrc into your home directory. Our default .vimrc set up vim such that it creates a backup copy of the file you are editing every time and store it in ~/.backup . This feature has saved me from pulling my hair out countless times. It is highly recommended that you set this up whenever you vim .","title":"Setting Up Your vim Environment"},{"location":"vim-practice/#lesson-1-navigation","text":"Now, you can stay in your home directory or go back to your workshop directory. Download the following file for practice using vim in this session. $ wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/jfk.txt The file named jfk.txt should be downloaded. Now let's start your first vim session. $ vim jfk.txt When you start, you will be in NORMAL mode. For now, just move around the cursor with H J K L . Get comfortable with using the keys. Next, try ( and ) to move forward and backward, sentence-by-sentence. Next, try { and } to move forward and backward, paragraph-by-paragraph. Use 0 to jump to the beginning of the line, and $ to jump to the end of the line. Use G + G to jump to the beginning of the file, and Shift + G ( G ) to jump to the last line of the file. Now try / , type in any word (or prefix of a word) and Enter . This should move the cursor to the beginning of the word. You can use N and P to move to the next match and the previous match. When you are comfortable with moving around, you can Shift + Z + Z to exit. Congratulations, you have just completed your first session in vim !","title":"Lesson 1: Navigation"},{"location":"vim-practice/#lesson-2-manipulating-text","text":"Now, we are going to open up the same file again and try to manipulate the text. We are going to stay in the NORMAL mode still. $ vim jfk.txt","title":"Lesson 2: Manipulating Text"},{"location":"vim-practice/#deletion","text":"Try 0 D 3 W to move the cursor to the beginning of the line and delete three words. Press U to undo. This is another lifesaver that you should remember. In vim , repeating the same command twice usually means applying it to the whole line. So D D deletes the current line. Try that. Pairing a command with Shift (or the capital letter version) usually means applying the action until the end of the line. So Shift + D deletes from the current cursor until the end of the line.","title":"Deletion"},{"location":"vim-practice/#copy-pasting","text":"Hit P to paste back what you just deleted. Try moving the cursor to somewhere else and paste. To copy (or yank) the current line, hit Y Y . Remember that all these commands can be composed using the movement-action-movement pattern. For instance, Shift + 9 Y Shift + 0 , which corresponds to: move to the beginning of the sentence, yank, and until the end of the sentence, basically copy the current sentence. As you have seen in the D 2 W example, you can preceed an action with a number to repeat an action multiple times. Try Y Y 9 P . You should be able to understand what just happened!","title":"Copy Pasting"},{"location":"vim-practice/#deleting-a-character","text":"The X command deletes the current character. Try this exercise: At the end of the file jfk.txt , there are some typos: libertyi. liberty. Change libertyi. liberty. to libtery. by positioning the cursor on the second i and delete it. Then use Shift + D to delete the extra liberty. at the end of the sentence.","title":"Deleting a Character"},{"location":"vim-practice/#visual-mode","text":"In addition to the INSERT and NORMAL modes, vim has the third mode, the VISUAL mode. You can enter the VISUAL mode by hitting V . Once in visual mode, you can move your cursor to select the text and perform some actions on it (e.g., D or X to delete, Y to yank). Hitting Shift + V will allow you to select line-by-line. The VISUAL mode allows us to pipe the selected text to another Unix command, and replace it with the result of that command. Go ahead and try to select a paragraph in jfk.txt , and hit : . You will see that :'<,'> appears in the last line of the terminal. At this point, you can type in actions that you want to perform on the selected text. For instance, :'<,'>w john.txt will write it to a file named john.txt . But, let's try the following: :'<,'>!fmt !fmt tells vim to invoke the shell and run fmt . fmt is another simple small Unix utility that takes in a text (from standard input) and spew out formatted text in the standard output. You will see that the width of the text has changed to the default of 65. You can try something that we have seen before. Reselect the text, and hit :'<,'>!wc The selected text will be replaced with the output from wc .","title":"Visual Mode"},{"location":"vim-practice/#the-command","text":"You have seen examples of : commands for writing to a file or piping selected text to an external command. The : command also opens up a large number of actions you can do in vim . Here are a few essential yet simple commands. To jump to a line, hit : followed by the line number. To open another file, hit : and then type in e <filename> To find help on a topic, hit : and then type in help <keyword> Other advanced features such as search-and-replace, changing preferences, splitting windows, opening new tabs, are also accessible from the : command. The : command prompt supports Ctrl + P and Ctrl + N for navigating back and forth your command history, just like bash . It also supports Tab for auto-completion.","title":"The : command"},{"location":"vim-practice/#lesson-3-insert-mode","text":"Finally, we are going to try inserting some text. Remember, to use INSERT mode, we always start with a command I A O or S (may paired with Shift ) followed by the text that you want to insert, followed by Esc . Let's try I (insert). Place your cursor anywhere, hit I , and start typing, when you are done. Hit Esc . You just added some text to the file. Place your cursor anywhere, hit A (append), and start typing, when you are done. Hit Esc . A appends the text to the end of the current line. Hit O (open) and start typing, when you are done. Hit Esc . O opens up a new line for the your text. Hit S (substitute) and start typing, when you are done. Hit Esc . S substitute the current character with your text. Now try it with Shift and see the difference in behavior.","title":"Lesson 3: Insert mode!"},{"location":"vim-practice/#learning-more","text":"There is only so much we can cover in 30 minutes. This workshop only covers the tip of the iceberg. To learn more about vim , we suggest that you run vimtutor on the command line and follow through the tutorials. Once you are comfortable, you can soup up your vim with various plugins and learn how to use advanced commands (such as search and replace, jumping between files, recording macros, folding, auto-completion) that are invaluable for programming. There are also many video tutorials and resources online. Some interesting ones are: Vim: Precision Editing at the Speed of Thought : A talk by Drew Neil Vim Adventure : An adventure game for learning vim Vim Casts : Videos and articles for teaching vim Vim Video Tutorials by Derek Wyatt Vim Awesome : Directory of plugins.","title":"Learning More"},{"location":"why-cli/","text":"Unit 2: Command-Line Interfaces What is Command-Line Interfaces? The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer. Why CLI over GUI? Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks. References The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"2. Why CLI?"},{"location":"why-cli/#unit-2-command-line-interfaces","text":"","title":"Unit 2: Command-Line Interfaces"},{"location":"why-cli/#what-is-command-line-interfaces","text":"The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer.","title":"What is Command-Line Interfaces?"},{"location":"why-cli/#why-cli-over-gui","text":"Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks.","title":"Why CLI over GUI?"},{"location":"why-cli/#references","text":"The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"References"},{"location":"why-unix/","text":"Unit 1: Unix History of Unix To understand what Unix is and to appreciate its importance, let's take a glimpse into the history book. Early computers, in the 1940s and early 1950s, do not have an operating system. Every program will have to be designed specifically for a given hardware specification and only one program can run on the computer at one time. To run a program, a user will have to carry a stack of punch cards or tapes into the computer room and load them into the computer at a scheduled time. As computers become more sophisticated and the demand to run programs on the machine increases, humans operators are hired to manage the requests to run the programs, and these human operators have to manually schedule and manage the time allocated to each program on the machine. These tasks are slowly being replaced by a layer of software that runs on the computers starting the late 1950s. Termed operating systems , this system software helps to manage \"which program runs when\", and it includes more functionalities such as resource accounting (e.g., which user used how much time on the machine) and hardware management (e.g., hide the tedious operations of interfacing with memory and storage from the programmer). One of the defining development in the 1960s is the idea of time sharing - allowing computer time to be shared by multiple users. Time-sharing is revolutionary since users no longer have to queue or schedule a slotted time to run a program on a computer. The early operating system that enables time-sharing, however, is complex, difficult to use, and bloated with features. Unix is an operating system that was developed in the late 1960s and the early 1970s around this revolution, by Dennis Ritchie and Ken Thompson from Bell Laboratories. Learning from the mistakes of the past operating systems, the duo set to develop an operating system with simplicity and elegance at the core of its design. Part of the push towards simplicity is also due to the lack of powerful computers in many places at that time -- the design constraints have lead to design decisions that favor economy. Figure: Ken thompson (sitting) and Dennis Ritchie working in front of their computer. The simplicity and elegance has propelled the popularity of the Unix operating system, leading to over 600 installations reported by 1974 3 . Closely tied to the rise of Unix is the invention of C, a programming language that Dennis Ritchie and Ken Thompson used to write Unix in. This is revolutionary by itself, as programmers can then write tools and programs in a higher level structured language, rather than in low-level assembly languages as in the operating systems before. As a result of this development, Unix is the first operating system where programmers can write and run a program on the fly in front of a terminal. This ability leads to a plethora of contributions to Unix systems, utilities, and tools in the 1970s, fueling its popularity among the developers. The ease of programming and its superiority in terms of simplicity has lead to the emergence of variants of the original Unix operating systems, developed by modifying the original Unix source code. The Berkeley Software Distribution (BSD) is among the most important ones (macOS is a descendant of BSD). Another notable descendant from the original Unix is Solaris, from Sun Microsystem (now Oracle), which the School of Computing runs on its computing server (called sunfire ). Another variant of Unix is Linux -- which interestingly is developed from scratch as a hobby initially by Linus Torvalds at the age of 21. Linux follows many of the principles of Unix but is not based on the original Unix source code. Figure: Unix and Unix-like Operating Systems. While a majority of personal computers is still running Microsoft Windows 10 (88%), a vast majority of server software is running on some flavor of Unix (>70%) 1 . Almost all mobile phones are running on a variant of Unix (iOS, Android). Among software developers, more than half (53%) uses a Unix-based OS on the primary work machines 2 . Microsoft, after years of competing with Unix-based OS, has started to embrace Unix-based systems and released the Windows Subsystems for Linux, allowing Windows users to run a sandboxed Linux subsystems within Windows. We collectively call these variants of operating systems and subsystems the Unix computing environment , which today includes all OS from Apple (macOS, iOS, etc), Linux-based systems (Ubuntu, Android, etc), commercial servers (Oracle's Solaris, HP's HP-UX, IBM's AIX), and subsystems within Microsoft Windows 10. Why Learn Unix? There are several reasons: Unix-based OS is the dominant operating system in the world, and as a computing student, you will likely have to interface with one sometime in your career. Unix design is rooted in its simplicity and economy. It is probably the most productive programming environment you can have to do most of your day-to-day tasks and to develop software as a computing professional. Unix design is also rooted in its programmability. If there is something that you wish to automate a task to improve your productivity, you can easily compose new tools from the existing ones. The Unix philosophy serves as a great example of how good software should be designed: simple, do one thing well, composable. Further Readings The Art of Unix Programming: History of Unix , by Eric Steven Raymond Stack Overflow Developer Survey 2020 \u21a9 Usage Share of OS , by Wikipedia \u21a9 The Unix Time Sharing System , by Dennis Ritchie and Ken Thompson. \u21a9","title":"1. Why Unix?"},{"location":"why-unix/#unit-1-unix","text":"","title":"Unit 1: Unix"},{"location":"why-unix/#history-of-unix","text":"To understand what Unix is and to appreciate its importance, let's take a glimpse into the history book. Early computers, in the 1940s and early 1950s, do not have an operating system. Every program will have to be designed specifically for a given hardware specification and only one program can run on the computer at one time. To run a program, a user will have to carry a stack of punch cards or tapes into the computer room and load them into the computer at a scheduled time. As computers become more sophisticated and the demand to run programs on the machine increases, humans operators are hired to manage the requests to run the programs, and these human operators have to manually schedule and manage the time allocated to each program on the machine. These tasks are slowly being replaced by a layer of software that runs on the computers starting the late 1950s. Termed operating systems , this system software helps to manage \"which program runs when\", and it includes more functionalities such as resource accounting (e.g., which user used how much time on the machine) and hardware management (e.g., hide the tedious operations of interfacing with memory and storage from the programmer). One of the defining development in the 1960s is the idea of time sharing - allowing computer time to be shared by multiple users. Time-sharing is revolutionary since users no longer have to queue or schedule a slotted time to run a program on a computer. The early operating system that enables time-sharing, however, is complex, difficult to use, and bloated with features. Unix is an operating system that was developed in the late 1960s and the early 1970s around this revolution, by Dennis Ritchie and Ken Thompson from Bell Laboratories. Learning from the mistakes of the past operating systems, the duo set to develop an operating system with simplicity and elegance at the core of its design. Part of the push towards simplicity is also due to the lack of powerful computers in many places at that time -- the design constraints have lead to design decisions that favor economy. Figure: Ken thompson (sitting) and Dennis Ritchie working in front of their computer. The simplicity and elegance has propelled the popularity of the Unix operating system, leading to over 600 installations reported by 1974 3 . Closely tied to the rise of Unix is the invention of C, a programming language that Dennis Ritchie and Ken Thompson used to write Unix in. This is revolutionary by itself, as programmers can then write tools and programs in a higher level structured language, rather than in low-level assembly languages as in the operating systems before. As a result of this development, Unix is the first operating system where programmers can write and run a program on the fly in front of a terminal. This ability leads to a plethora of contributions to Unix systems, utilities, and tools in the 1970s, fueling its popularity among the developers. The ease of programming and its superiority in terms of simplicity has lead to the emergence of variants of the original Unix operating systems, developed by modifying the original Unix source code. The Berkeley Software Distribution (BSD) is among the most important ones (macOS is a descendant of BSD). Another notable descendant from the original Unix is Solaris, from Sun Microsystem (now Oracle), which the School of Computing runs on its computing server (called sunfire ). Another variant of Unix is Linux -- which interestingly is developed from scratch as a hobby initially by Linus Torvalds at the age of 21. Linux follows many of the principles of Unix but is not based on the original Unix source code. Figure: Unix and Unix-like Operating Systems. While a majority of personal computers is still running Microsoft Windows 10 (88%), a vast majority of server software is running on some flavor of Unix (>70%) 1 . Almost all mobile phones are running on a variant of Unix (iOS, Android). Among software developers, more than half (53%) uses a Unix-based OS on the primary work machines 2 . Microsoft, after years of competing with Unix-based OS, has started to embrace Unix-based systems and released the Windows Subsystems for Linux, allowing Windows users to run a sandboxed Linux subsystems within Windows. We collectively call these variants of operating systems and subsystems the Unix computing environment , which today includes all OS from Apple (macOS, iOS, etc), Linux-based systems (Ubuntu, Android, etc), commercial servers (Oracle's Solaris, HP's HP-UX, IBM's AIX), and subsystems within Microsoft Windows 10.","title":"History of Unix"},{"location":"why-unix/#why-learn-unix","text":"There are several reasons: Unix-based OS is the dominant operating system in the world, and as a computing student, you will likely have to interface with one sometime in your career. Unix design is rooted in its simplicity and economy. It is probably the most productive programming environment you can have to do most of your day-to-day tasks and to develop software as a computing professional. Unix design is also rooted in its programmability. If there is something that you wish to automate a task to improve your productivity, you can easily compose new tools from the existing ones. The Unix philosophy serves as a great example of how good software should be designed: simple, do one thing well, composable.","title":"Why Learn Unix?"},{"location":"why-unix/#further-readings","text":"The Art of Unix Programming: History of Unix , by Eric Steven Raymond Stack Overflow Developer Survey 2020 \u21a9 Usage Share of OS , by Wikipedia \u21a9 The Unix Time Sharing System , by Dennis Ritchie and Ken Thompson. \u21a9","title":"Further Readings"},{"location":"wsl/","text":"Setting Up Unix Computing Environment on Windows 10 with WSL WSL, or Windows Subsystem for Linux , is a subsystem that allows users to run a Unix computing environment within Windows 10. This is the recommended method for having a local Unix computing environment for your Windows 10 machine, for the purpose of CS1010, CS2030, CS2030S, and CS2040 in Semester 1, AY2020/21. There are two versions, WSL 1 and, a newer, WSL 2. For the Unix@Home workshop, it suffices for attendees to install WSL 1. Requirements Before you proceed with the instructions below, you need to make sure that: You have 64-bit versions of Windows 10, version 1607 or higher ( Here is how you check ); You have administrator access to your Windows 10; And You have an SoC Unix account. You can create an SoC Unix account here . For SoC students, this username is something that sticks with you for the rest of your SoC life -- so choose wisely. Installing WSL 1 Step 1: Enabling WSL on Windows 10 through PowerShell Before you install WSL 1, you need to first enable the \"Windows Subsystem for Linux\" feature by running the following command in PowerShell. dism . exe / online / enable-feature / featurename : Microsoft-Windows-Subsystem-Linux / all / norestart You can achieve this step by: Hit Win to open the Start menu, type PowerShell , then right-click on Windows PowerShell, and click \"Run as administrator\" Copy the command above by selecting it and then hitting Ctrl + C Go to your PowerShell window and paste the command above by hitting Ctrl + V . Press enter if needed to run the command. Step 2: Restart your computer Step 3: Install Ubuntu After restarting your computer, go to the Microsoft Store and get Ubuntu 18.04 LTS. 1 Follow the on-screen instructions to install. When you are asked to create a user account and password, we suggest that you choose a Unix username that is that same as your SoC Unix username. Launching WSL To launch WSL, you can hit Win + R and type in Ubuntu followed by Enter . This should bring up the Unix command-line interface for you to interact with the Unix computing environment. Getting ready to install tools WSL comes with apt as the package manager, which is a convenient way to list, search, install, update, and uninstall software and libraries in WSL. After you have set up WSL, run the following: sudo apt update What it does: apt is a command to install, upgrade, search, and uninstall software and other packages in Ubuntu. apt update asks apt to obtain the latest list of available packages from the Internet. sudo performs apt update with a super-user's level permission. This command may ask you to enter your password. (Note: super-user means administrator in Unix). The latest Ubuntu 20.04 LTS is reported reported to be unstable on WSL 1. \u21a9","title":"Setup for Windows 10"},{"location":"wsl/#setting-up-unix-computing-environment-on-windows-10-with-wsl","text":"WSL, or Windows Subsystem for Linux , is a subsystem that allows users to run a Unix computing environment within Windows 10. This is the recommended method for having a local Unix computing environment for your Windows 10 machine, for the purpose of CS1010, CS2030, CS2030S, and CS2040 in Semester 1, AY2020/21. There are two versions, WSL 1 and, a newer, WSL 2. For the Unix@Home workshop, it suffices for attendees to install WSL 1.","title":"Setting Up Unix Computing Environment on Windows 10 with WSL"},{"location":"wsl/#requirements","text":"Before you proceed with the instructions below, you need to make sure that: You have 64-bit versions of Windows 10, version 1607 or higher ( Here is how you check ); You have administrator access to your Windows 10; And You have an SoC Unix account. You can create an SoC Unix account here . For SoC students, this username is something that sticks with you for the rest of your SoC life -- so choose wisely.","title":"Requirements"},{"location":"wsl/#installing-wsl-1","text":"","title":"Installing WSL 1"},{"location":"wsl/#step-1-enabling-wsl-on-windows-10-through-powershell","text":"Before you install WSL 1, you need to first enable the \"Windows Subsystem for Linux\" feature by running the following command in PowerShell. dism . exe / online / enable-feature / featurename : Microsoft-Windows-Subsystem-Linux / all / norestart You can achieve this step by: Hit Win to open the Start menu, type PowerShell , then right-click on Windows PowerShell, and click \"Run as administrator\" Copy the command above by selecting it and then hitting Ctrl + C Go to your PowerShell window and paste the command above by hitting Ctrl + V . Press enter if needed to run the command.","title":"Step 1: Enabling WSL on Windows 10 through PowerShell"},{"location":"wsl/#step-2-restart-your-computer","text":"","title":"Step 2: Restart your computer"},{"location":"wsl/#step-3-install-ubuntu","text":"After restarting your computer, go to the Microsoft Store and get Ubuntu 18.04 LTS. 1 Follow the on-screen instructions to install. When you are asked to create a user account and password, we suggest that you choose a Unix username that is that same as your SoC Unix username.","title":"Step 3: Install Ubuntu"},{"location":"wsl/#launching-wsl","text":"To launch WSL, you can hit Win + R and type in Ubuntu followed by Enter . This should bring up the Unix command-line interface for you to interact with the Unix computing environment.","title":"Launching WSL"},{"location":"wsl/#getting-ready-to-install-tools","text":"WSL comes with apt as the package manager, which is a convenient way to list, search, install, update, and uninstall software and libraries in WSL. After you have set up WSL, run the following: sudo apt update What it does: apt is a command to install, upgrade, search, and uninstall software and other packages in Ubuntu. apt update asks apt to obtain the latest list of available packages from the Internet. sudo performs apt update with a super-user's level permission. This command may ask you to enter your password. (Note: super-user means administrator in Unix). The latest Ubuntu 20.04 LTS is reported reported to be unstable on WSL 1. \u21a9","title":"Getting ready to install tools"}]}